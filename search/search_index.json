{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>This tutorial covers various uses of the <code>pyproject.toml</code> file for Python projects.</p> <p>It was developed for PyCon Greece 2025.</p> <p>The source can be found on GitHub.</p> <p>This material is licensed under CC BY 4.0. See the README.md file in the source repository for more details and attribution information.</p>"},{"location":"appendix/","title":"Appendix: Converting existing configurations","text":"<p>The tools we have seen in the tutorial can read their configuration from a variety of file formats. Before <code>pyproject.toml</code> became standard, many projects used different files, and some continue to do so.</p> <p>This appendix has you migrate from older-style configurations to using <code>pyproject.toml</code>. It also discusses some additional tools which were not mentioned in the main tutorial.</p> <p>The starter code comes with some sample configurations in the <code>old-configs</code> directory.</p>"},{"location":"appendix/#packaging","title":"Packaging","text":"<p>The dependencies and other project metadata are provided in <code>setup.py</code>. Move that to the <code>[project]</code> table of <code>pyproject.toml</code>.</p> <p>The <code>setup.py</code> format is not deprecated, although commands like <code>python setup.py install</code> and <code>python setup.py develop</code> are no longer favoured. Instead, you should use <code>pip</code> to install a package from source. PyPA has a guide for modernizing <code>setup.py</code>-based projects.</p>"},{"location":"appendix/#linting","title":"Linting","text":"<p>Ruff uses TOML files for configuration (either its own <code>ruff.toml</code> or <code>pyproject.toml</code>), but older linters look for a number of filenames.</p> <p>Two sample configurations are provided in <code>pylintrc</code> and <code>.flake8</code>, for Pylint and Flake8 respectively.</p> <p>Pylint supports <code>pyproject.toml</code>, so you can recreate the same configuration in that file. On the other hand, Flake8 cannot be configured in <code>pyproject.toml</code>. However, Ruff supports the whole set of Flake8 rules in its own rules, so you can construct an equivalent configuration for Ruff.</p>"},{"location":"appendix/#formatting","title":"Formatting","text":"<p>The black formatter can be configured only in <code>pyproject.toml</code>.</p> <p>The isort utility can be configured with various files, including <code>pyproject.toml</code> and <code>.isort.cfg</code> (as in the sample config). The formats are very similar.</p> <p>If using Ruff for linting, you may also want to use it for auto-formatting. Currently, Ruff implements the isort rules under its linter, in the \"I\" rules category. You can recreate the configuration from <code>.isort.cfg</code> in Ruff, as indicated in its docs.</p>"},{"location":"appendix/#type-checking","title":"Type checking","text":"<p>Mypy can store configuration in <code>pyproject.toml</code> or an ini file. The two formats are very similar, with the main difference being the name of the sections, particularly for overrides. You should therefore be able to recreate the configuration from <code>mypy.ini</code>.</p> <p>You can read more on the differences in the mypy docs, which also contain an example <code>pyproject.toml</code>.</p>"},{"location":"introduction/","title":"Introduction","text":""},{"location":"introduction/#the-pyprojecttoml-file","title":"The <code>pyproject.toml</code> file","text":"<p>Tools in the Python ecosystem have used a variety of formats to store their configuration. More recently, <code>pyproject.toml</code> has emerged as a standardised file that can specify information about a project itself, as well as configuration options for various useful tools.</p> <p>In this tutorial, we'll explore how to to use this file for packaging a project and for customizing tools like linters and type checkers, with the goal of improving the quality of a codebase.</p>"},{"location":"introduction/#learning-goals","title":"Learning goals","text":"<p>After completing this tutorial, you will be able to:</p> <ul> <li>interpret basic metadata for a project by looking at its <code>pyproject.toml</code>.</li> <li>specify dependencies and command-line entrypoints for your package.</li> <li>enable and configure linting and type-checking for a codebase.</li> </ul>"},{"location":"introduction/#how-to-use-this-tutorial","title":"How to use this tutorial","text":"<p>The different chapters are intended to be followed in order.</p> <p>If you are already familiar with tools like <code>ruff</code> and <code>mypy</code>, you can skip to the Appendix after completing the Setting Up and Packaging chapters.</p> <p>Sections that look like this:</p> <p>Try it out</p> <p>invite you to experiment. They have you see the effect of the configuration you have built, and are a core part of the tutorial.</p> <p>Sections that look like this:</p> <p>Here's a tip</p> <p>contain more advanced suggestions. You don't need to read or follow them to complete the tutorial.</p> <p>Most chapters include a list of further resources at the end. You can refer to these if you want more information on a specific topic, although there will likely not be enough time to take them all in during the tutorial.</p>"},{"location":"linting/","title":"Linting","text":"<p>As codebases become larger, it is easier for mistakes to creep in. Linters are tools that check the code for signs of potential problems, like unused variables or uncommon usage patterns.</p> <p>There are numerous linters for Python, and many of them can be configured through <code>pyproject.toml</code>. For this tutorial, we will use Ruff, a relatively recent suite of linters and formatters tools, which draws inspiration from previous tools.</p>"},{"location":"linting/#install-the-linter","title":"Install the linter","text":"<p>Like many Python analysis tools, Ruff is available as a package we an install.</p> <p>The linter is an optional dependency: we need it while developing, but it's not something we want our users to install. We'll therefore put it in a separate category of development-only requirements.</p> <p>Add the following to your <code>pyproject.toml</code>:</p> <pre><code>[project.optional-dependencies]\ndev = [\n    \"ruff\",\n]\n</code></pre> <p>Install the new dependency</p> <p>Run <code>python -m pip install .[dev]</code></p> <p>This will install your core package along with the <code>dev</code> \"extra\". You should see that <code>pip</code> is searching for <code>ruff</code> and its dependencies.</p>"},{"location":"linting/#run-the-linter-and-address-issues","title":"Run the linter and address issues","text":"<p>Now that it's installed, we can use the linter.</p> <p>Run the linter</p> <p>Run <code>python -m ruff check src</code> from the root of your project.</p> <p>Look at the error reported about an unused variable. The error is correctly identified, but the solution suggested is perhaps not the best... Address the error however you think is best, and rerun <code>ruff</code> to check that it reports no problems.</p>"},{"location":"linting/#configure-linting","title":"Configure linting","text":"<p><code>ruff</code> uses a default set of rules when checking your code, but it can be customized to add or remove from that rulset. This is useful when you want to be stricter or, conversely, you want to ignore a particular rule.</p> <p>Add the following section in <code>pyproject.toml</code>:</p> <pre><code>[tool.ruff.lint]\nselect = [\n    \"E\",\n    \"F\",\n    \"B\",\n    \"SIM\",\n    \"I\",\n    \"ARG\"\n]\n</code></pre> <p>The above configuration specifies the set of rules to use.</p> <p>Try the new configuration</p> <p>Rerun the linter. You should now seem some additional errors.</p> <p>Each error is accompanied by a code like <code>UP015</code>, indicating the rule it violates. The rules are grouped in categories starting with the same letter. For example, <code>I</code> indicates rules related to the ordering of imports, while <code>ARG</code> rules have to do with function arguments. With the above configuration, we have asked Ruff to check the categories <code>E</code>, <code>F</code> and so on.</p> <p>In our case, the additional category detected a bug: we are not using one of the function's arguments. Assuming this is unintentional, change the function body to fix the bug (use the <code>y</code> argument however you want).</p> <p>Rerun <code>ruff</code> to check that the errors are gone.</p> <p>Exclude files from linting</p> <p>Ruff will try to detect all relevant files to check, but sometimes you may want to exclude some files from it. For example, when you installed your package, <code>pip</code> may have created a <code>build</code> directory with a copy of your code. Running Ruff on those files will generally report the same errors as in <code>src</code>, which is redundant.</p> <p>We have been working around this by restricting the folder that <code>ruff</code> looks at through passing the extra command-line argument <code>src</code>, but it can be easier to configure this in <code>pyproject.toml</code>.</p> <p>Add the following entry in the file, below the previous configuration: <pre><code>[tool.ruff.lint]\n...\nexclude = [\"build/**\"]\n</code></pre></p> <p>Now you can simply run <code>python -m ruff check</code>, and the <code>build</code> diretory will be ignored. This also gives you finer-grained control, since you can exclude individual files.</p>"},{"location":"linting/#further-resources","title":"Further resources","text":"<ul> <li>The Ruff documentation describes the different rules you can select from.</li> <li>It also explains how to ignore a rule, either entirely or for individual lines or files.</li> <li>Flake8 is another popular linter which can be customized similarly.</li> <li>Ruff can also be used for automatic formatting of your Python code, enforcing rules like line length and naming conventions. Other formatters include black and pycodestyle.</li> </ul>"},{"location":"packaging/","title":"Packaging","text":"<p>A main use of <code>pyproject.toml</code> is for defining project metadata. This includes:</p> <ul> <li>the name of your project, and your contact information,</li> <li>the versions of Python it is compatible with,</li> <li>the packages it depends on,</li> <li>the command-line tools it provides.</li> </ul> <p>This information is used to build and install the project, as well as when publishing it on PyPI.</p> <p>All this information is stored in the <code>[project]</code> table of the <code>pyproject.toml</code> file.</p>"},{"location":"packaging/#basic-metadata","title":"Basic metadata","text":"<p>Add the following section to your file:</p> <pre><code>[project]\nname = \"my-package\"\nversion = \"0.1\"\nauthors =  [\n    {name = \"Firstname Lastname\", email = \"me@me.org\"}\n]\ndescription = \"A really cool project\"\nlicense = \"Apache-2.0\"\nlicense-files = [\"LICENSE.md\"]\nkeywords = [\"science\", \"magic\"]\n</code></pre> <p>You can change the authors or project name to values of your choice.</p> <p>Note that:</p> <ul> <li>The project <code>name</code> is how other projects will refer to yours, e.g. when declaring their dependency on it.</li> <li>The <code>name</code> cannot contain spaces.</li> <li>The <code>keywords</code> make it easier to find your project on PyPI when searching for those terms. </li> </ul> <p>Avoid hardcoding the version</p> <p>You can set the version dynamically, based on some property in your code.</p> <p>Change the <code>version = \"0.1\"</code> line above to <code>dynamic = [\"version\"]</code>. Then add a new section: <pre><code>[tool.setuptools.dynamic]\nversion = {attr = \"my_package.__version__\"}\n</code></pre></p> <p>This will read the version from the <code>__version__</code> variable in <code>my_package/__init__.py</code>.</p>"},{"location":"packaging/#dependencies","title":"Dependencies","text":"<p>If your project uses other Python packages, you should generally make sure they are installed alongside it. You can declare declare what your package needs in order to run in <code>pyproject.toml</code>. This includes:</p> <ul> <li>what versions of Python it is compatible with,</li> <li>any other other packages it requires.</li> </ul> <p>Add the following entries in the <code>project</code> table, below the metadata:</p> <pre><code>[project]\n...\nrequires-python = \"&gt;= 3.10\"\ndependencies = [\n    \"pyyaml\"\n]\n</code></pre> <p>Install your package</p> <p>Navigate to the project directory and run <code>python -m pip install .</code></p> <p>Among the output, you should see a message like <pre><code>Collecting pyyaml (from my-package==1.0)\n</code></pre> indicating that <code>pip</code> is installing for your package's dependencies!</p> <p>Also note the line <pre><code>Successfully installed my-package-0.1\n</code></pre> which reflects the version of your package, as specified in <code>pyproject.toml</code>.</p>"},{"location":"packaging/#entrypoints","title":"Entrypoints","text":"<p>When writing a package, you sometimes want to create a way of accessing its functionality from the command line. For example, the <code>pytest</code> package creates an executable that can be called with <code>pytest</code> on a terminal. You can use <code>pyproject.toml</code> to define any command-line entrypoints that your package provides.</p> <p>Add the following section in your file:</p> <pre><code>[project.scripts]\ndemo = \"my_package.cli:run\"\n</code></pre> <p>With this configuration, when your package is installed, <code>pip</code> will create a script that:</p> <ul> <li>can be executed with the command <code>demo</code>, and</li> <li>when executed, it runs the function <code>run</code> from <code>cli.py</code> in your package.</li> </ul> <p>Try out the entrypoint</p> <p>Install your package again with <code>python -m pip install .</code> to have the new change take effect. When the re-installation is complete, run <code>demo</code> on the terminal.</p> <p>You should see something like: <pre><code>Trying out combine_arguments with x='A', y='B', z=4\nResult is A4\n</code></pre></p> <p>Open the <code>cli.py</code> file and verify that this is the output from the <code>run</code> function.</p> <p>You have now made it possible for others to use your package both as a library and as a command-line tool!</p>"},{"location":"packaging/#further-resources","title":"Further resources","text":"<ul> <li>The Python Packaging Authority (PyPA) provides a comprehensive guide to writing a pyproject.toml file.</li> <li>PyPA also maintains the latest version of the formal specification.</li> <li>The docs for <code>setuptools</code> (the default build backend) include a guide for how to configure <code>pyproject.toml</code> for it. Other backends may have their own guidance.</li> <li>PEP 621 proposed what project metadata should be stored.</li> </ul>"},{"location":"setup/","title":"Setting up","text":"<p>The tutorial will take you through using <code>pyproject.toml</code> in an example codebase. Before you start, you need to set up your environment.</p> <p>These setup steps assume that you have access to:</p> <ul> <li>a Python installation (version 3.8 or more recent),</li> <li>a way to run Python from a shell,</li> <li>an internet connection.</li> </ul>"},{"location":"setup/#create-an-environment","title":"Create an environment","text":"<p>The tutorial will have you install various packages. To avoid interfering with other Python projects you may have, use a virtual environment. This can be done with the <code>venv</code> package from the Python standard library.</p> <p>Note</p> <ul> <li>The commands below assume Python 3.12. Substitute your own version when calling the <code>python</code> executable.</li> <li>If you are using Anaconda, you can create and activate the environment using the <code>conda</code> commands instead of the below.</li> </ul> <ol> <li> <p>In a shell, create a virtual environment by running the command:</p> Linux/Mac/WSLWindows <pre><code>python3.12 -m venv pyproject-tutorial\n</code></pre> <pre><code>py -m venv pyproject-tutorial\n</code></pre> </li> <li> <p>Activate the environment with</p> Linux/Mac/WSLWindows <pre><code>source pyproject-tutorial/bin/activate\n</code></pre> <pre><code>pyproject-tutorial\\Scripts\\activate\n</code></pre> </li> </ol> <p>You will be installing Python packages into this virtual environment through the course of the tutorial. While you keep this shell open, the environment will remain active unless you deactivate it.</p>"},{"location":"setup/#get-the-starter-code","title":"Get the starter code","text":"<p>Download the starter code by going to the Releases page, downloading the <code>pyproject-sample.zip</code> file and unzipping it.</p> <p>You should have the following structure:</p> <pre><code>(project root)\n\u251c\u2500\u2500 pyproject.toml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 LICENSE\n    \u2514\u2500\u2500 my_package\n     \u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n     \u00a0\u00a0 \u251c\u2500\u2500 cli.py\n     \u00a0\u00a0 \u251c\u2500\u2500 experimental.py\n     \u00a0\u00a0 \u2514\u2500\u2500 library.py\n</code></pre> <p>The <code>pyproject.toml</code> contains a very basic configuration, which you will be extending during the tutorial. The rest of the code is only there as an example and does not do anything particularly interesting! It has also purposefully been written to contain some issues, which you will be fixing with the tools covered in the tutorial.</p> <p>You're now ready to start!</p>"},{"location":"type_checking/","title":"Type checking","text":"<p>Python is a dynamically-typed language and encourages duck-typing. With this flexibility comes the risk of runtime errors due to unsupported types, which can be hard to recover from and to replicate.</p> <p>Type checkers analyse a codebase statically and can detect when types are used inconsistently - for example, not respecting a function's type hints, or combining values of different types in a way that is not guaranteed to work. This can uncover potential bugs or edge cases where the code would fail at runtime, but without needing to execute it.</p> <p>Here we will use mypy, a static type checker, to further validate our package's codebase.</p>"},{"location":"type_checking/#install-and-run-the-type-checker","title":"Install and run the type checker","text":"<p>Like with linters, a type checker is an optional dependency.</p> <p>Modify <code>pyproject.toml</code> to  also install <code>mypy</code> as part of the <code>dev</code> extra:</p> <pre><code>[project.optional-dependencies]\ndev = [\n    \"ruff\",\n    \"mypy\",\n]\n</code></pre> <p>Run mypy</p> <p>Run <code>python -m pip install .[dev]</code>. Verify that <code>pip</code> now also installs the <code>mypy</code> package.</p> <p>Run <code>python -m mypy src</code>.</p> <p>Look at the errors for <code>library.py</code>. Compare the error messages to the type hints for the relevant functions, and try to understand why mypy is complaining.</p> <p>One error concerns an incorrect function invocation, while the others are bugs in the logic. The syntax is correct, the linter did not detect them, and the code may not have failed at runtime, but using the type checker has helped prevent them!</p> <p>Use the error messages to fix the problems. Rerun mypy and verify that no errors are reported.</p>"},{"location":"type_checking/#configure-mypy","title":"Configure mypy","text":"<p>Like with linters, mypy can be configured to be more or less strict, and to ignore specific files.</p> <p>To get the most thorough checks, you can specify the <code>strict</code> option. This is useful once you have a type-safe codebase, but it may report too many errors if you are still building up the code!</p> <p>To enable this option, add a new section in <code>pyproject.toml</code>:</p> <pre><code>[tool.mypy]\nstrict = true\n</code></pre> <p>Try the new configuration</p> <p>Rerun mypy with <code>python -m mypy src</code>. You should now see more errors across two files.</p> <p>For <code>cli.py</code>, mypy is complaining about missing type annotations. This is something that it requires when run in strict mode. Add the annotation as the message suggests.</p> <p>For <code>experimental.py</code>, the errors reflect that the file is still being actively worked on. We could address them, but the code is likely to change. In this case, strict mode is perhaps inappropriate for this file.</p> <p>The easiest way around this is to tell mypy we don't want it to check anything in that file:</p> <pre><code>[tool.mypy]\n...\nexclude = [\"experimental.py\"]\n</code></pre> <p>Rerun mypy to verify that errors for that file are not reported.</p> <p>Per-module overrides</p> <p>Mypy allows you to customise what options are applied to different files. For the example above, maybe you don't want to completely exclude <code>experimental.py</code>, but you also don't want to handle it in strict mode. Mypy lets you do this with an override for that file.</p> <p>To try this, remove the <code>exclude</code> option given above, and instead add another section:</p> <p><pre><code>[[tool.mypy.overrides]]\nmodule = \"my_package.experimental\"\ndisallow_untyped_defs = false\nwarn_return_any = false\n</code></pre> (note the double brackets <code>[[...]]</code> in the section name!)</p> <p>This disables the two rules that were giving errors earlier, specifically for this module. Other rules still apply to it, and those two rules are still applied to other files.</p> <p>Run mypy again and confirm that there are no errors for <code>experimental.py</code>.</p>"},{"location":"type_checking/#further-resources","title":"Further resources","text":"<ul> <li>The mypy docs have a lot of information, including an introduction to mypy and type-checking and a detailed list of available configuration options.</li> <li>Pyright is an alternative type checker.</li> </ul>"}]}